<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PWD Red Flag Detection - Production</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #FFFFFF;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #FFE5D9 0%, #FFDAC7 100%);
            border-radius: 12px;
        }

        .header h1 {
            font-size: 32px;
            color: #333;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 24px;
            margin-bottom: 30px;
        }

        .upload-section {
            background: #FFFFFF;
            border: 2px dashed #FFD4C0;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
        }

        .upload-section:hover {
            border-color: #FFB399;
            background: #FFFAF8;
        }

        .upload-section.dragging {
            background: #FFF5F0;
            border-color: #FF9966;
        }

        .upload-button {
            background: #FFB399;
            color: #333;
            padding: 14px 32px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
        }

        .upload-button:hover {
            background: #FF9966;
        }

        .file-input {
            display: none;
        }

        .processing {
            text-align: center;
            padding: 40px;
            background: #FFF5F0;
            border-radius: 12px;
            margin: 20px 0;
        }

        .spinner {
            border: 4px solid #FFE5D9;
            border-top: 4px solid #FFB399;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .document-analysis {
            background: #FFFFFF;
            border: 2px solid #FFE5D9;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 30px;
        }

        .doc-header {
            background: linear-gradient(135deg, #FFE5D9 0%, #FFDAC7 100%);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .doc-title {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #FFE5D9;
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
        }

        .data-item {
            background: #FFF5F0;
            padding: 12px;
            border-radius: 6px;
        }

        .data-label {
            font-weight: 600;
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .data-value {
            color: #333;
            font-size: 16px;
            word-break: break-word;
        }

        .data-value.highlight {
            background: #FFFACD;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .extraction-quality {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            margin-left: 12px;
        }

        .extraction-quality.excellent {
            background: #4CAF50;
            color: #FFFFFF;
        }

        .extraction-quality.good {
            background: #8BC34A;
            color: #FFFFFF;
        }

        .extraction-quality.fair {
            background: #FFC107;
            color: #333;
        }

        .extraction-quality.poor {
            background: #FF6B6B;
            color: #FFFFFF;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: #FFFFFF;
            font-size: 13px;
            margin-top: 12px;
        }

        .data-table th {
            background: #FFB399;
            color: #333;
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            font-size: 12px;
        }

        .data-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #FFE5D9;
        }

        .data-table tr:hover {
            background: #FFF5F0;
        }

        .toggle-button {
            background: #FFFFFF;
            border: 2px solid #FFB399;
            color: #333;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 8px;
        }

        .toggle-button:hover {
            background: #FFB399;
        }

        .collapsible {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible.open {
            max-height: 3000px;
        }

        .raw-text {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #333;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 300px;
            overflow-y: auto;
            background: #F5F5F5;
            padding: 12px;
            border-radius: 6px;
        }

        .flag-alert {
            background: #FFF5F0;
            border: 2px solid #FFB399;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .flag-alert.critical {
            border-color: #FF6B6B;
            background: #FFE5E5;
        }

        .flag-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }

        .flag-icon {
            background: #FFB399;
            color: #333;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            flex-shrink: 0;
        }

        .flag-alert.critical .flag-icon {
            background: #FF6B6B;
            color: #FFFFFF;
        }

        .flag-info {
            flex: 1;
        }

        .flag-name {
            font-size: 18px;
            font-weight: 700;
            color: #333;
            margin-bottom: 4px;
        }

        .flag-description {
            color: #666;
            font-size: 14px;
            line-height: 1.5;
        }

        .flag-severity {
            background: #FFB399;
            color: #333;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .flag-severity.critical {
            background: #FF6B6B;
            color: #FFFFFF;
        }

        .flag-evidence {
            background: #FFFFFF;
            padding: 16px;
            border-radius: 6px;
            margin-top: 12px;
        }

        .evidence-title {
            font-weight: 700;
            color: #333;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .evidence-item {
            display: flex;
            padding: 8px 0;
            border-bottom: 1px solid #F0F0F0;
        }

        .evidence-item:last-child {
            border-bottom: none;
        }

        .evidence-label {
            font-weight: 600;
            color: #666;
            min-width: 200px;
        }

        .evidence-value {
            color: #333;
            flex: 1;
        }

        .no-flags {
            background: #E8F5E9;
            border: 2px solid #4CAF50;
            padding: 40px;
            border-radius: 8px;
            text-align: center;
        }

        .no-flags-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .summary-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #FFB399;
            color: #333;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            margin-top: 12px;
        }

        .summary-badge.clean {
            background: #4CAF50;
            color: #FFFFFF;
        }

        .export-section {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
        }

        .export-button {
            background: #FFB399;
            color: #333;
            padding: 12px 32px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin: 0 8px;
        }

        .export-button:hover {
            background: #FF9966;
        }

        .export-button.secondary {
            background: #FFFFFF;
            border: 2px solid #FFB399;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #FFE5D9;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: #FFB399;
            transition: width 0.3s ease;
        }

        .extraction-debug {
            background: #FFF9E6;
            border: 1px solid #FFD700;
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
            font-size: 12px;
        }

        .debug-title {
            font-weight: 700;
            color: #CC8800;
            margin-bottom: 8px;
        }

        .field-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            margin: 2px;
        }

        .field-status.found {
            background: #4CAF50;
            color: white;
        }

        .field-status.missing {
            background: #FF6B6B;
            color: white;
        }

        .format-selection {
            margin-top: 16px;
            text-align: left;
        }

        .checkbox-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .checkbox-label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: #333;
        }

        .excel-results {
            background: #FFFFFF;
            border: 2px solid #FFE5D9;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 30px;
        }

        .download-grid {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 16px;
        }

        .download-btn {
            text-decoration: none;
            background: #FFB399;
            color: #333;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    {% raw %}
    <script type="text/babel">
        const { useState, useRef } = React;

        const normalizeKey = (value) =>
            String(value || '')
                .toLowerCase()
                .replace(/[^a-z0-9]/g, '');

        const toNumber = (value) => {
            if (value === null || value === undefined) return null;
            const cleaned = String(value).replace(/[,₹\s]/g, '');
            const num = parseFloat(cleaned);
            return Number.isFinite(num) ? num : null;
        };

        const toDateValue = (value) => {
            if (!value) return null;
            if (value instanceof Date) return value;
            if (typeof value === 'number' && window.XLSX?.SSF?.parse_date_code) {
                const parsed = XLSX.SSF.parse_date_code(value);
                if (parsed) {
                    return new Date(parsed.y, parsed.m - 1, parsed.d);
                }
            }
            if (typeof value === 'string') {
                const parts = value.split(/[-\/]/);
                if (parts.length >= 3) {
                    return new Date(parts[2], parts[1] - 1, parts[0]);
                }
                const parsed = new Date(value);
                return Number.isNaN(parsed.getTime()) ? null : parsed;
            }
            return null;
        };

        const extractRoadNumber = (workName) => {
            if (!workName) return null;
            const patterns = [
                { regex: /SH-?\s*(\d+)/i, prefix: 'SH' },
                { regex: /MDR-?\s*(\d+)/i, prefix: 'MDR' },
                { regex: /NH-?\s*(\d+)/i, prefix: 'NH' }
            ];
            for (const { regex, prefix } of patterns) {
                const match = workName.match(regex);
                if (match) {
                    return `${prefix}${match[1]}`;
                }
            }
            return null;
        };

        const buildLineText = (items) => {
            const rows = {};
            items.forEach((item) => {
                const y = Math.round(item.transform[5]);
                const x = item.transform[4];
                if (!rows[y]) rows[y] = [];
                rows[y].push({ x, text: item.str });
            });
            return Object.keys(rows)
                .sort((a, b) => b - a)
                .map((y) =>
                    rows[y]
                        .sort((a, b) => a.x - b.x)
                        .map((entry) => entry.text)
                        .join(' ')
                        .trim()
                )
                .filter(Boolean)
                .join('\n');
        };

        // Enhanced extraction with multiple fallback patterns
        function extractDataFromText(text, fileName, pageTexts) {
            const data = {
                fileName: fileName,
                rawText: text.substring(0, 3000),
                fullTextLength: text.length,
                pageTexts: pageTexts,
                
                // Core fields
                workName: '',
                workId: null,
                division: null,
                userDepartment: null,
                depositWorkId: null,
                type: 'capital_work',
                
                // Financial data
                aaAmount: null,
                aaDate: null,
                aaNumber: null,
                technicalSanctionAmount: null,
                contractAmount: null,
                cumulativeExpenditure: null,
                balanceAmount: null,
                totalReceived: null,
                
                // Timeline data
                workOrderDate: null,
                originalTimeLimitDays: null,
                extendedTimeLimit: null,
                
                // Agency info
                mainAgency: null,
                
                // Bills
                expenditureDetails: [],
                
                // Extraction metadata
                extractionQuality: 0,
                extractedFields: [],
                missingFields: [],
                debugInfo: []
            };

            // Clean text for better pattern matching
            const cleanText = text.replace(/\s+/g, ' ');
            
            // WORK ID - Multiple patterns
            let workIdMatch = text.match(/Work\s+ID[:\s]+([A-Z0-9\/]+)/i);
            if (!workIdMatch) workIdMatch = text.match(/Work\s*ID\s*:?\s*([A-Z]{3}\/\d{2}\/\d{3}\/\d{5})/i);
            if (workIdMatch) {
                data.workId = workIdMatch[1].trim();
                data.extractedFields.push('Work ID');
            } else {
                data.missingFields.push('Work ID');
            }

            // DEPOSIT WORK ID - More flexible pattern
            let depositIdMatch = text.match(/Deposit\s+Work\s+ID[:\s]*([0-9\/A-Z]+)/i);
            if (depositIdMatch) {
                data.depositWorkId = depositIdMatch[1].trim();
                data.type = 'deposit_work';
                data.extractedFields.push('Deposit Work ID');
            }

            // DIVISION - Enhanced pattern
            let divisionMatch = text.match(/Division[:\s]+(\d{10})\s*-\s*([^\n]+?)(?=Sub|Scheme|Work|$)/i);
            if (!divisionMatch) divisionMatch = text.match(/Division[:\s]+([^\n]+?)(?=Sub|Scheme|$)/i);
            if (divisionMatch) {
                data.division = divisionMatch[0].replace('Division', '').replace(/[:]/g, '').trim();
                data.extractedFields.push('Division');
            } else {
                data.missingFields.push('Division');
            }

            // USER DEPARTMENT
            let userDeptMatch = text.match(/User\s+Department[:\s]*([^\n]+?)(?=Administrative|$)/i);
            if (userDeptMatch) {
                data.userDepartment = userDeptMatch[1].trim();
                data.type = 'deposit_work';
                data.extractedFields.push('User Department');
            }

            // WORK NAME - Enhanced extraction
            let workNameMatch = text.match(/Name\s+[Oo]f\s+[Ww]ork[^:]*:[:\s]*(.*?)(?=Name\s+Of\s+The\s+Work|User\s+Department|Administrative|$)/is);
            if (!workNameMatch) {
                workNameMatch = text.match(/Construction\s+Of\s+[^\n]{20,200}/i);
            }
            if (!workNameMatch) {
                workNameMatch = text.match(/Improvement[^\n]{20,200}/i);
            }
            if (workNameMatch) {
                data.workName = workNameMatch[1] ? workNameMatch[1].trim().replace(/\s+/g, ' ').substring(0, 300) : workNameMatch[0].substring(0, 300);
                data.extractedFields.push('Work Name');
            } else {
                data.missingFields.push('Work Name');
            }

            // TYPE DETECTION
            if (text.toLowerCase().includes('utilisation certificate') || 
                text.toLowerCase().includes('deposit work') ||
                text.toLowerCase().includes('user department')) {
                data.type = 'deposit_work';
                data.extractedFields.push('Work Type: Deposit');
            }

            // AA AMOUNT - Multiple patterns with better number extraction
            let aaMatch = text.match(/AA\s+Amount[^:]*:[^0-9]*(?:Rs\.?\s*)?([0-9,]+)/i);
            if (!aaMatch) aaMatch = text.match(/Administrative\s+Approval[^:]*Amount[^:]*:[^0-9]*([0-9,]+)/i);
            if (!aaMatch) aaMatch = text.match(/AA\s+Amount\s+in\s+Rupees[^:]*:[^0-9]*(?:Rs\.?\s*)?([0-9,]+)/i);
            if (aaMatch) {
                data.aaAmount = aaMatch[1].replace(/,/g, '');
                data.extractedFields.push('AA Amount');
            } else {
                data.missingFields.push('AA Amount');
            }

            // AA DATE
            let aaDateMatch = text.match(/Administrative\s+Approval\s+Date[:\s]*([0-9]{2}[-\/-][0-9]{2}[-\/-][0-9]{4})/i);
            if (aaDateMatch) {
                data.aaDate = aaDateMatch[1];
                data.extractedFields.push('AA Date');
            }

            // AA NUMBER
            let aaNumberMatch = text.match(/Administrative\s+Approval\s+No\.?[:\s]*([^\n]+?)(?=Administrative|AA|$)/i);
            if (aaNumberMatch) {
                data.aaNumber = aaNumberMatch[1].trim().substring(0, 100);
                data.extractedFields.push('AA Number');
            }

            // TECHNICAL SANCTION
            let tsMatch = text.match(/Technical\s+Sanction\s+Amt[^:]*:[^0-9]*(?:Rs\.?\s*)?([0-9,]+)/i);
            if (tsMatch) {
                data.technicalSanctionAmount = tsMatch[1].replace(/,/g, '');
                data.extractedFields.push('Tech Sanction Amount');
            }

            // CONTRACT AMOUNT
            let contractMatch = text.match(/Contract\s+Agreement\s+Amt[^:]*:[^0-9]*(?:Rs\.?\s*)?([0-9,]+)/i);
            if (contractMatch) {
                data.contractAmount = contractMatch[1].replace(/,/g, '');
                data.extractedFields.push('Contract Amount');
            }

            // MAIN AGENCY
            let agencyMatch = text.match(/Main\s+Agency\s+Name[:\s]*([^\n]+?)(?=Scope|Provision|$)/i);
            if (agencyMatch) {
                data.mainAgency = agencyMatch[1].trim();
                data.extractedFields.push('Main Agency');
            }

            // CUMULATIVE EXPENDITURE - Get the maximum value
            let allCumulativeMatches = [...text.matchAll(/Cumulative[^:]*(?:Expenditure|Amount)[^:]*:[^0-9]*([0-9,]+)/gi)];
            if (!allCumulativeMatches.length) {
                allCumulativeMatches = [...text.matchAll(/Up-to-date\s+expenditure[^:]*:[^0-9]*([0-9,]+)/gi)];
            }
            
            let maxCumulative = 0;
            allCumulativeMatches.forEach(match => {
                const value = parseInt(match[1].replace(/,/g, ''));
                if (value > maxCumulative) maxCumulative = value;
            });
            
            if (maxCumulative > 0) {
                data.cumulativeExpenditure = maxCumulative;
                data.extractedFields.push('Cumulative Expenditure');
            } else {
                data.missingFields.push('Cumulative Expenditure');
            }

            // BALANCE AMOUNT
            let balanceMatch = text.match(/balance\s+amount[^:]*:[^0-9]*(?:Rs\.?\s*)?([0-9,]+)/i);
            if (balanceMatch) {
                data.balanceAmount = balanceMatch[1].replace(/,/g, '');
                data.extractedFields.push('Balance Amount');
            }

            // TOTAL RECEIVED
            let receivedMatch = text.match(/sanctioned[^:]*:[^0-9]*(?:Rs\.?\s*)?([0-9,]+)/i);
            if (!receivedMatch) receivedMatch = text.match(/Received[^:]*:[^0-9]*([0-9,]+)/i);
            if (receivedMatch) {
                data.totalReceived = receivedMatch[1].replace(/,/g, '');
                data.extractedFields.push('Total Received');
            }

            // WORK ORDER DATE
            let workOrderMatch = text.match(/Date\s+Of\s+Work\s+Order[:\s]*([0-9]{2}[-\/-][0-9]{2}[-\/-][0-9]{4})/i);
            if (workOrderMatch) {
                data.workOrderDate = workOrderMatch[1];
                data.extractedFields.push('Work Order Date');
            }

            // ORIGINAL TIME LIMIT
            let timeLimitMatch = text.match(/Original\s+Time\s+Limit\s+[Ii]n\s+Days[:\s]*([0-9]+)/i);
            if (timeLimitMatch) {
                data.originalTimeLimitDays = timeLimitMatch[1];
                data.extractedFields.push('Original Time Limit');
            }

            // EXTENDED TIME LIMIT
            let extendedMatch = text.match(/Extended\s+Time\s+Limit[^:]*:[^0-9]*([0-9]{2}[-\/-][0-9]{2}[-\/-][0-9]{4})/i);
            if (extendedMatch) {
                data.extendedTimeLimit = extendedMatch[1];
                data.extractedFields.push('Extended Time Limit');
            }

            // EXPENDITURE DETAILS - ENHANCED TABLE PARSING
            const lines = text.split('\n');
            let inTableSection = false;
            let tableHeaders = [];
            
            // First, try structured table extraction
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Detect table start
                if (line.match(/Financial\s+Year|Expenditure\s+Details|Payment\s+Details/i)) {
                    inTableSection = true;
                    // Try to get headers from next line
                    if (i + 1 < lines.length) {
                        const headerLine = lines[i + 1];
                        if (headerLine.match(/RA\s+Bill|Date|Name|Amount|Remark/i)) {
                            tableHeaders = headerLine.split(/\s{2,}|\t/).map(h => h.trim());
                        }
                    }
                    continue;
                }
                
                if (inTableSection && line.length > 20) {
                    // Pattern 1: Standard table row with Financial Year
                    let match = line.match(/(\d{4}-\d{4})\s+([^0-9]+?)\s+(\d{2}[-\/]\d{2}[-\/]\d{4})\s+(?:(\d+)\s+)?([^0-9]+?)\s+([\d,]+)\s+([\d,]+)\s+([\d,]+)\s+(.+)$/);
                    
                    if (match) {
                        const [, financialYear, billType, date, billNo, agencyName, billAmount, centage, cumulative, remark] = match;
                        data.expenditureDetails.push({
                            financialYear: financialYear.trim(),
                            billType: billType.trim(),
                            date: date.trim(),
                            billNumber: billNo ? billNo.trim() : '',
                            agencyName: agencyName.trim(),
                            billAmount: billAmount.replace(/,/g, ''),
                            centageAmount: centage.replace(/,/g, ''),
                            cumulativeAmount: cumulative.replace(/,/g, ''),
                            remark: remark.trim()
                        });
                        continue;
                    }
                    
                    // Pattern 2: Without financial year, focus on date
                    match = line.match(/(\d{2}[-\/]\d{2}[-\/]\d{4})\s+([^0-9]+?)\s+([\d,]+)\s+([\d,]+)\s+([\d,]+)\s+(.+)$/);
                    if (match) {
                        const [, date, agencyName, billAmount, centage, cumulative, remark] = match;
                        data.expenditureDetails.push({
                            date: date.trim(),
                            agencyName: agencyName.trim(),
                            billAmount: billAmount.replace(/,/g, ''),
                            centageAmount: centage.replace(/,/g, ''),
                            cumulativeAmount: cumulative.replace(/,/g, ''),
                            remark: remark.trim()
                        });
                        continue;
                    }
                }
            }

            // Fallback: Simple date-amount pattern
            if (data.expenditureDetails.length === 0) {
                const simplePattern = /(\d{2}[-\/]\d{2}[-\/]\d{4})[^\d]+([\d,]+)[^\d]+([\d,]+)[^\n]*?([^\n]{10,100})/g;
                let matches = [...text.matchAll(simplePattern)];
                
                matches.forEach((match, idx) => {
                    data.expenditureDetails.push({
                        date: match[1],
                        billNumber: (idx + 1).toString(),
                        agencyName: 'Extracted from text',
                        billAmount: match[2].replace(/,/g, ''),
                        cumulativeAmount: match[3].replace(/,/g, ''),
                        remark: match[4].trim(),
                        centageAmount: '0'
                    });
                });
            }

            if (data.expenditureDetails.length > 0) {
                data.expenditureDetails = data.expenditureDetails.filter((item) =>
                    item.billAmount || item.remark || item.date
                );
                data.extractedFields.push(`${data.expenditureDetails.length} Bill(s)`);
            } else {
                data.missingFields.push('Bill Details');
            }

            // Calculate extraction quality
            const criticalFields = ['workId', 'workName', 'aaAmount', 'cumulativeExpenditure'];
            const importantFields = ['division', 'userDepartment', 'balanceAmount', 'workOrderDate'];
            
            let score = 0;
            criticalFields.forEach(field => {
                if (data[field]) score += 25;
            });
            importantFields.forEach(field => {
                if (data[field]) score += 5;
            });
            if (data.expenditureDetails.length > 0) score += 20;
            
            data.extractionQuality = Math.min(100, Math.round(score));

            return data;
        }

        const parseExcelFile = async (file) => {
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });

            const headerMap = {
                workId: ['workid', 'workidno', 'workidnumber'],
                depositWorkId: ['depositworkid', 'depositid'],
                budgetItemNo: ['budgetitemno', 'budgetitemnumber', 'budgetitem'],
                nameOfWork: ['nameofthework', 'nameofwork', 'workname'],
                aaAmount: ['administrativeapprovalcostlakh', 'aaamount', 'aaamountinrupees'],
                totalExpenditure: ['totalexpenditurelakhs', 'totalexpenditure', 'cumulativeexpenditure'],
                contractCost: ['contractagreementcostlakh', 'contractamount', 'contractcost'],
                workOrderDate: ['dateofwork_order', 'dateofworkorder', 'workorderdate'],
                timeLimit: ['originaltimelimitindays', 'timelimitdays'],
                roadCategory: ['roadcategory'],
                chainageFrom: ['chainagefrom', 'fromkm'],
                chainageTo: ['chainageto', 'tokm'],
                contractorName: ['contractorname', 'agencyname', 'contractor']
            };

            const resolveField = (row, keys) => {
                const normalizedKeys = Object.keys(row).reduce((acc, key) => {
                    acc[normalizeKey(key)] = key;
                    return acc;
                }, {});
                for (const key of keys) {
                    if (normalizedKeys[key]) return row[normalizedKeys[key]];
                }
                return '';
            };

            return rows.map((row) => ({
                raw: row,
                workId: resolveField(row, headerMap.workId),
                depositWorkId: resolveField(row, headerMap.depositWorkId),
                budgetItemNo: resolveField(row, headerMap.budgetItemNo),
                nameOfWork: resolveField(row, headerMap.nameOfWork),
                aaAmount: toNumber(resolveField(row, headerMap.aaAmount)),
                totalExpenditure: toNumber(resolveField(row, headerMap.totalExpenditure)),
                contractCost: toNumber(resolveField(row, headerMap.contractCost)),
                workOrderDate: resolveField(row, headerMap.workOrderDate),
                workOrderDateObj: toDateValue(resolveField(row, headerMap.workOrderDate)),
                timeLimitDays: toNumber(resolveField(row, headerMap.timeLimit)),
                roadCategory: resolveField(row, headerMap.roadCategory),
                chainageFrom: toNumber(resolveField(row, headerMap.chainageFrom)),
                chainageTo: toNumber(resolveField(row, headerMap.chainageTo)),
                contractorName: resolveField(row, headerMap.contractorName),
            }));
        };

        const tokenSimilarity = (a, b) => {
            if (!a || !b) return 0;
            const ignore = new Set(['the', 'of', 'and', 'road', 'roads', 'construction', 'improvement', 'work', 'works']);
            const tokensA = a.toLowerCase().split(/\s+/).filter((t) => t.length > 3 && !ignore.has(t));
            const tokensB = b.toLowerCase().split(/\s+/).filter((t) => t.length > 3 && !ignore.has(t));
            if (!tokensA.length || !tokensB.length) return 0;
            const matches = tokensA.filter((t) => tokensB.includes(t)).length;
            return matches / Math.max(tokensA.length, tokensB.length);
        };

        const matchPdfToExcel = (pdfData, excelRecords) => {
            if (!excelRecords || excelRecords.length === 0) {
                return { record: null, score: 0, reason: 'No Excel records available' };
            }

            let best = { record: null, score: 0, reason: 'No match' };
            excelRecords.forEach((record) => {
                let score = 0;
                let reason = '';

                if (pdfData.workId && record.workId && normalizeKey(pdfData.workId) === normalizeKey(record.workId)) {
                    score = 100;
                    reason = 'Matched by Work ID';
                } else if (
                    pdfData.depositWorkId &&
                    record.depositWorkId &&
                    normalizeKey(pdfData.depositWorkId) === normalizeKey(record.depositWorkId)
                ) {
                    score = 98;
                    reason = 'Matched by Deposit Work ID';
                } else if (
                    pdfData.workId &&
                    record.budgetItemNo &&
                    normalizeKey(pdfData.workId) === normalizeKey(record.budgetItemNo)
                ) {
                    score = 85;
                    reason = 'Matched by Budget Item No';
                } else {
                    const similarity = tokenSimilarity(pdfData.workName, record.nameOfWork);
                    if (similarity >= 0.55) {
                        score = Math.round(similarity * 100);
                        reason = 'Matched by Work Name similarity';
                    }
                }

                if (score > best.score) {
                    best = { record, score, reason };
                }
            });

            if (best.score < 55) {
                return { record: null, score: best.score, reason: 'No strong match found' };
            }

            return best;
        };

        const findOverlappingWorks = (record, excelRecords) => {
            if (!record || !excelRecords || !record.chainageFrom || !record.chainageTo) return [];
            const baseRoad = extractRoadNumber(record.nameOfWork || '');
            if (!baseRoad) return [];
            return excelRecords.filter((item) => {
                if (item === record || !item.chainageFrom || !item.chainageTo) return false;
                const road = extractRoadNumber(item.nameOfWork || '');
                if (!road || road !== baseRoad) return false;
                return !(item.chainageTo < record.chainageFrom || item.chainageFrom > record.chainageTo);
            });
        };

        const findSplittingGroup = (record, excelRecords) => {
            if (!record || !excelRecords) return [];
            const baseRoad = extractRoadNumber(record.nameOfWork || '');
            if (!baseRoad) return [];
            const year = record.workOrderDateObj ? record.workOrderDateObj.getFullYear() : null;
            const candidates = excelRecords.filter((item) => {
                const itemRoad = extractRoadNumber(item.nameOfWork || '');
                if (!itemRoad || itemRoad !== baseRoad) return false;
                const itemYear = item.workOrderDateObj ? item.workOrderDateObj.getFullYear() : null;
                if (year && itemYear && itemYear !== year) return false;
                if (item.contractCost === null || item.contractCost >= 10) return false;
                if (record.contractorName && item.contractorName) {
                    return normalizeKey(record.contractorName) === normalizeKey(item.contractorName);
                }
                return true;
            });
            return candidates.length >= 3 ? candidates : [];
        };

        const buildRedFlagResults = (pdfData, excelMatch, excelRecords) => {
            const flags = [];
            const matchRecord = excelMatch?.record || null;

            const getAaAmount = () => {
                return matchRecord?.aaAmount || toNumber(pdfData.aaAmount);
            };
            const getExpenditure = () => {
                return matchRecord?.totalExpenditure || toNumber(pdfData.cumulativeExpenditure);
            };

            // 1. Diversion of Funds
            if (pdfData.type === 'deposit_work' && pdfData.expenditureDetails?.length) {
                pdfData.expenditureDetails.forEach((item, index) => {
                    if (item.remark && pdfData.workName) {
                        const remarkLower = item.remark.toLowerCase();
                        const workLower = pdfData.workName.toLowerCase();
                        const workTerms = workLower.split(/\s+/).filter((w) => w.length > 4);
                        const matchingTerms = workTerms.filter((term) => remarkLower.includes(term));
                        const matchRatio = workTerms.length > 0 ? matchingTerms.length / workTerms.length : 0;
                        if (matchRatio < 0.3 && workTerms.length > 0) {
                            flags.push({
                                ruleId: 1,
                                ruleName: 'Diversion of Funds',
                                severity: 'high',
                                description: 'Remark differs materially from sanctioned work name.',
                                details: {
                                    'Sanctioned Work': pdfData.workName,
                                    'Bill Remark': item.remark,
                                    'Bill Amount': `₹ ${parseInt(item.billAmount || 0).toLocaleString('en-IN')}`,
                                    'Bill Date': item.date || 'Not specified',
                                    'Match Score': `${(matchRatio * 100).toFixed(0)}%`,
                                    'Audit Reference': 'PW Manual Para 305'
                                }
                            });
                        }
                    }
                });
            }

            // 2. Wasteful Survey Expenditure
            if (pdfData.expenditureDetails?.length) {
                const surveyBills = pdfData.expenditureDetails.filter((item) =>
                    item.remark && item.remark.toLowerCase().includes('survey')
                );
                const nonSurveyBills = pdfData.expenditureDetails.filter((item) =>
                    !item.remark || !item.remark.toLowerCase().includes('survey')
                );
                const nonSurveyPaid = nonSurveyBills.filter((item) => parseInt(item.billAmount || 0) > 0);
                if (surveyBills.length > 0 && nonSurveyPaid.length === 0) {
                    const totalSurvey = surveyBills.reduce((sum, b) => sum + parseInt(b.billAmount || 0), 0);
                    flags.push({
                        ruleId: 2,
                        ruleName: 'Unfruitful Survey Expenditure',
                        severity: 'high',
                        description: 'Survey bills exist but no other paid items found.',
                        details: {
                            'Survey Bills Found': surveyBills.length,
                            'Total Survey Expenditure': `₹ ${totalSurvey.toLocaleString('en-IN')}`,
                            'Construction Bills Paid': '0',
                            'Audit Reference': 'Tender conditions - survey before work'
                        }
                    });
                }
            }

            // 3. Excess Expenditure (>10% AA)
            const aaAmount = getAaAmount();
            const expenditure = getExpenditure();
            if (aaAmount && expenditure && expenditure > aaAmount * 1.1) {
                const excess = expenditure - aaAmount;
                const excessPercent = ((excess / aaAmount) * 100).toFixed(2);
                flags.push({
                    ruleId: 3,
                    ruleName: 'Excess Expenditure Without Approval',
                    severity: 'critical',
                    description: 'Expenditure exceeds AA by more than 10%.',
                    details: {
                        'AA Amount': `₹ ${aaAmount.toLocaleString('en-IN')}`,
                        'Expenditure': `₹ ${expenditure.toLocaleString('en-IN')}`,
                        'Excess': `₹ ${excess.toLocaleString('en-IN')} (${excessPercent}%)`
                    }
                });
            }

            // 4. Overlapping Work
            if (matchRecord) {
                const overlaps = findOverlappingWorks(matchRecord, excelRecords);
                if (overlaps.length > 0) {
                    flags.push({
                        ruleId: 4,
                        ruleName: 'Overlapping Works',
                        severity: 'high',
                        description: 'Chainage overlap detected with other works on same road.',
                        details: {
                            'Matched Work': matchRecord.nameOfWork || 'N/A',
                            'Overlapping Records': overlaps.map((item) => item.nameOfWork).join(' | ')
                        }
                    });
                }
            }

            // 5. Delay in Completion
            const workOrder = pdfData.workOrderDate || matchRecord?.workOrderDate || null;
            const workOrderDate = toDateValue(workOrder) || matchRecord?.workOrderDateObj || null;
            const timeLimit = pdfData.originalTimeLimitDays || matchRecord?.timeLimitDays;
            if (workOrderDate && timeLimit) {
                const completion = new Date(workOrderDate.getTime() + parseInt(timeLimit, 10) * 86400000);
                if (new Date() > completion) {
                    const delayDays = Math.floor((new Date() - completion) / 86400000);
                    flags.push({
                        ruleId: 5,
                        ruleName: 'Delay in Completion of Work',
                        severity: 'high',
                        description: 'Work exceeded stipulated completion date.',
                        details: {
                            'Work Order Date': workOrderDate.toLocaleDateString('en-IN'),
                            'Time Limit (Days)': timeLimit,
                            'Delay (Days)': delayDays
                        }
                    });
                }
            }

            // 6. Splitting of Works
            if (matchRecord) {
                const splitGroup = findSplittingGroup(matchRecord, excelRecords);
                if (splitGroup.length >= 3) {
                    flags.push({
                        ruleId: 6,
                        ruleName: 'Splitting of Work',
                        severity: 'high',
                        description: 'Multiple small works on same road in same year.',
                        details: {
                            'Road': extractRoadNumber(matchRecord.nameOfWork || '') || 'N/A',
                            'Number of Works': splitGroup.length,
                            'Contractor': matchRecord.contractorName || 'Not specified'
                        }
                    });
                }
            }

            // 7. Non-recovery of Centage Charges
            if (pdfData.type === 'deposit_work' && pdfData.expenditureDetails?.length) {
                let violations = 0;
                let totalBill = 0;
                let totalCentage = 0;
                pdfData.expenditureDetails.forEach((item) => {
                    const bill = parseInt(item.billAmount || 0);
                    const centage = parseInt(item.centageAmount || 0);
                    totalBill += bill;
                    totalCentage += centage;
                    if (bill > 0 && centage < bill * 0.05 * 0.9) {
                        violations++;
                    }
                });
                if (violations > 0) {
                    const expected = totalBill * 0.05;
                    const shortfall = expected - totalCentage;
                    flags.push({
                        ruleId: 7,
                        ruleName: 'Non-Recovery of Centage Charges',
                        severity: 'medium',
                        description: 'Centage charges not recovered on deposit works.',
                        details: {
                            'Bills with Violation': violations,
                            'Expected Centage (5%)': `₹ ${expected.toLocaleString('en-IN')}`,
                            'Recovered': `₹ ${totalCentage.toLocaleString('en-IN')}`,
                            'Shortfall': `₹ ${shortfall.toLocaleString('en-IN')}`
                        }
                    });
                }
            }

            // 8. Unspent Balance Not Returned
            if (pdfData.type === 'deposit_work' && pdfData.balanceAmount) {
                const balance = parseInt(pdfData.balanceAmount || 0);
                if (balance > 100000) {
                    const hasCompleted = pdfData.expenditureDetails?.some((item) =>
                        item.remark && item.remark.toLowerCase().includes('completed')
                    );
                    if (hasCompleted) {
                        flags.push({
                            ruleId: 8,
                            ruleName: 'Unspent Balance Not Returned',
                            severity: 'high',
                            description: 'Balance remains with DDO after completion.',
                            details: {
                                'Balance with DDO': `₹ ${balance.toLocaleString('en-IN')}`,
                                'User Department': pdfData.userDepartment || 'Not specified'
                            }
                        });
                    }
                }
            }

            return flags;
        };

        async function parseDocument(file) {
            const fileType = file.name.toLowerCase();
            if (fileType.endsWith('.pdf')) {
                return await parsePDF(file);
            } else if (fileType.endsWith('.docx')) {
                return await parseDOCX(file);
            }
            throw new Error('Unsupported file type');
        }

        async function parsePDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            let fullText = '';
            let pageTexts = [];
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = buildLineText(textContent.items);
                pageTexts.push({ page: i, text: pageText });
                fullText += pageText + '\n\n';
            }
            
            return extractDataFromText(fullText, file.name, pageTexts);
        }

        async function parseDOCX(file) {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            return extractDataFromText(result.value, file.name, [{ page: 1, text: result.value }]);
        }

        // Main App Component
        function App() {
            const [pdfFile, setPdfFile] = useState(null);
            const [excelFile, setExcelFile] = useState(null);
            const [processing, setProcessing] = useState(false);
            const [progress, setProgress] = useState(0);
            const [analysisResult, setAnalysisResult] = useState(null);
            const [analysisError, setAnalysisError] = useState(null);
            const [dragging, setDragging] = useState(false);
            const fileInputRef = useRef(null);
            const excelInputRef = useRef(null);

            const handlePdfSelect = (e) => {
                const selected = e.target.files[0];
                setPdfFile(selected || null);
                setAnalysisResult(null);
                setAnalysisError(null);
            };

            const handleExcelSelect = (e) => {
                const selected = e.target.files[0];
                setExcelFile(selected || null);
                setAnalysisResult(null);
                setAnalysisError(null);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                setDragging(true);
            };

            const handleDragLeave = () => {
                setDragging(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setDragging(false);
                const droppedFile = e.dataTransfer.files[0];
                if (droppedFile) {
                    setPdfFile(droppedFile);
                    setAnalysisResult(null);
                    setAnalysisError(null);
                }
            };

            const analyzeDocuments = async () => {
                if (!pdfFile) {
                    setAnalysisError('Please upload the Utilisation Certificate PDF to proceed.');
                    return;
                }

                setProcessing(true);
                setProgress(10);
                setAnalysisError(null);

                try {
                    const pdfData = await parseDocument(pdfFile);
                    setProgress(45);

                    let excelRecords = [];
                    if (excelFile) {
                        excelRecords = await parseExcelFile(excelFile);
                    }
                    setProgress(70);

                    const matchInfo = excelFile ? matchPdfToExcel(pdfData, excelRecords) : null;
                    const flags = buildRedFlagResults(pdfData, matchInfo, excelRecords);

                    setAnalysisResult({
                        fileName: pdfFile.name,
                        extractedData: pdfData,
                        flags,
                        matchInfo,
                        excelRecordCount: excelRecords.length
                    });
                    setProgress(100);
                } catch (error) {
                    setAnalysisError(error.message || 'Analysis failed.');
                } finally {
                    setProcessing(false);
                }
            };

            const exportExcelReport = () => {
                if (!analysisResult) return;
                const doc = analysisResult;
                const summaryRows = [
                    {
                        File: doc.fileName,
                        Work: doc.extractedData?.workName || 'N/A',
                        Type: doc.extractedData?.type || 'N/A',
                        'AA Amount': doc.extractedData?.aaAmount || 'N/A',
                        'Cumulative Expenditure': doc.extractedData?.cumulativeExpenditure || 'N/A',
                        'Red Flags': doc.flags?.length || 0,
                        'Extraction Quality': `${doc.extractedData?.extractionQuality || 0}%`
                    }
                ];

                const flagRows = doc.flags.map((flag) => ({
                    File: doc.fileName,
                    Rule: flag.ruleName,
                    Severity: flag.severity,
                    Details: Object.entries(flag.details || {})
                        .map(([k, v]) => `${k}: ${v}`)
                        .join(' | ')
                }));

                const workbook = XLSX.utils.book_new();
                const summarySheet = XLSX.utils.json_to_sheet(summaryRows);
                XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

                if (flagRows.length > 0) {
                    const flagSheet = XLSX.utils.json_to_sheet(flagRows);
                    XLSX.utils.book_append_sheet(workbook, flagSheet, 'Red Flags');
                }

                XLSX.writeFile(workbook, `PWD_Report_${new Date().toISOString().split('T')[0]}.xlsx`);
            };

            const exportPdfReport = () => {
                if (!analysisResult) return;
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF();
                const marginX = 14;
                let y = 18;

                pdf.setFontSize(16);
                pdf.text('PWD Red Flag Detection Report', marginX, y);
                y += 8;
                pdf.setFontSize(10);
                pdf.text(`Generated: ${new Date().toLocaleString('en-IN')}`, marginX, y);
                y += 10;

                const doc = analysisResult;
                const addLine = (label, value) => {
                    const text = `${label}: ${value}`;
                    const lines = pdf.splitTextToSize(text, 180);
                    pdf.text(lines, marginX, y);
                    y += lines.length * 5;
                };

                addLine('File', doc.fileName);
                addLine('Work', doc.extractedData?.workName || 'N/A');
                addLine('Work ID', doc.extractedData?.workId || doc.extractedData?.depositWorkId || 'N/A');
                addLine('Red Flags', doc.flags?.length || 0);

                y += 6;
                pdf.setFontSize(12);
                pdf.text('Red Flag Details', marginX, y);
                y += 6;
                pdf.setFontSize(9);

                doc.flags.forEach((flag) => {
                    if (y > 270) {
                        pdf.addPage();
                        y = 20;
                    }
                    const header = `${flag.ruleName} (${flag.severity})`;
                    pdf.text(pdf.splitTextToSize(header, 180), marginX, y);
                    y += 5;
                    Object.entries(flag.details || {}).forEach(([k, v]) => {
                        const detailLine = `• ${k}: ${v}`;
                        const lines = pdf.splitTextToSize(detailLine, 175);
                        pdf.text(lines, marginX + 2, y);
                        y += lines.length * 4.5;
                    });
                    y += 4;
                });

                if (doc.flags.length === 0) {
                    pdf.text('No red flags detected for this work.', marginX, y);
                }

                pdf.save(`PWD_Report_${new Date().toISOString().split('T')[0]}.pdf`);
            };

            return (
                <div className="container">
                    <div className="header">
                        <h1> PWD Red Flag Detection</h1>
                        <p>Enhanced Extraction & Analysis System</p>
                    </div>

                    <div className="upload-grid">
                        <div
                            className={`upload-section ${dragging ? 'dragging' : ''}`}
                            onDragOver={handleDragOver}
                            onDragLeave={handleDragLeave}
                            onDrop={handleDrop}
                        >
                            <h2 style={{ marginBottom: '12px' }}>Utilisation Certificate (PDF/DOCX)</h2>
                            <p style={{ marginBottom: '20px', color: '#666' }}>
                                Upload the Utilisation Certificate to extract work details and bill information.
                            </p>
                            <button className="upload-button" onClick={() => fileInputRef.current?.click()}>
                                Select PDF/DOCX File
                            </button>
                            <input
                                ref={fileInputRef}
                                type="file"
                                className="file-input"
                                accept=".pdf,.docx"
                                onChange={handlePdfSelect}
                            />
                            <p style={{ marginTop: '12px', color: '#666' }}>
                                {pdfFile ? pdfFile.name : 'No file selected'}
                            </p>
                        </div>

                        <div className="upload-section">
                            <h2 style={{ marginBottom: '12px' }}>Transaction Records (Excel)</h2>
                            <p style={{ marginBottom: '20px', color: '#666' }}>
                                Upload the Excel register to map Work IDs and validate transactions.
                            </p>
                            <button className="upload-button" onClick={() => excelInputRef.current?.click()}>
                                Select Excel File
                            </button>
                            <input
                                ref={excelInputRef}
                                type="file"
                                className="file-input"
                                accept=".xlsx,.xls"
                                onChange={handleExcelSelect}
                            />
                            <p style={{ marginTop: '12px', color: '#666' }}>
                                {excelFile ? excelFile.name : 'Optional - no Excel file selected'}
                            </p>
                        </div>
                    </div>

                    <div style={{ textAlign: 'center', marginBottom: '24px' }}>
                        <button
                            className="upload-button"
                            onClick={analyzeDocuments}
                            disabled={processing}
                            style={{ fontSize: '18px', padding: '16px 48px' }}
                        >
                            {processing ? 'Analyzing...' : 'Analyze Red Flags'}
                        </button>
                        {analysisError && (
                            <p style={{ marginTop: '12px', color: '#FF6B6B' }}>{analysisError}</p>
                        )}
                    </div>

                    {processing && (
                        <div className="processing">
                            <div className="spinner"></div>
                            <p><strong>Processing:</strong> {pdfFile?.name || 'Document'}</p>
                            <div className="progress-bar">
                                <div className="progress-fill" style={{ width: `${progress}%` }}></div>
                            </div>
                        </div>
                    )}

                    {analysisResult && (
                        <>
                            <div className="export-section">
                                <button className="export-button" onClick={exportExcelReport}>
                                    Export Excel Report
                                </button>
                                <button className="export-button" onClick={exportPdfReport}>
                                    Export PDF Report
                                </button>
                                <button 
                                    className="export-button secondary" 
                                    onClick={() => { setAnalysisResult(null); setPdfFile(null); setExcelFile(null); }}
                                >
                                    New Analysis
                                </button>
                            </div>

                            <DocumentAnalysis doc={analysisResult} />
                        </>
                    )}
                </div>
            );
        }

        function DocumentAnalysis({ doc }) {
            const [showRawText, setShowRawText] = useState(false);
            const [showBills, setShowBills] = useState(false);

            const data = doc.extractedData;
            const qualityClass = data.extractionQuality >= 80 ? 'excellent' : 
                                 data.extractionQuality >= 60 ? 'good' :
                                 data.extractionQuality >= 40 ? 'fair' : 'poor';
            const matchInfo = doc.matchInfo;
            const matchedRecord = matchInfo?.record || null;

            return (
                <div className="document-analysis">
                    <div className="doc-header">
                        <div className="doc-title">
                             {doc.fileName}
                        </div>
                        <div style={{ marginTop: '8px' }}>
                            <span className={`extraction-quality ${qualityClass}`}>
                                Extraction: {data.extractionQuality}%
                            </span>
                            {doc.flags.length === 0 ? (
                                <span className="summary-badge clean">✓ Compliant</span>
                            ) : (
                                <span className="summary-badge">⚠ {doc.flags.length} Red Flags</span>
                            )}
                        </div>
                    </div>

                    <div className="section">
                        <div className="section-title">Extracted Data</div>
                        
                        <div className="data-grid">
                            <div className="data-item">
                                <div className="data-label">Work ID</div>
                                <div className="data-value">{data.workId || data.depositWorkId || 'Not found'}</div>
                            </div>
                            <div className="data-item">
                                <div className="data-label">Type</div>
                                <div className="data-value">{data.type === 'deposit_work' ? 'Deposit' : 'Capital'}</div>
                            </div>
                            <div className="data-item">
                                <div className="data-label">Division</div>
                                <div className="data-value">{data.division || 'Not found'}</div>
                            </div>
                            <div className="data-item">
                                <div className="data-label">Excel Match</div>
                                <div className="data-value">
                                    {matchedRecord
                                        ? `${matchedRecord.nameOfWork || 'Matched'} (${matchInfo.score}%)`
                                        : doc.excelRecordCount
                                            ? 'No match found'
                                            : 'Excel not provided'}
                                </div>
                            </div>
                        </div>

                        <div style={{ marginTop: '16px' }}>
                            <div className="data-item">
                                <div className="data-label">Work Name</div>
                                <div className="data-value">{data.workName || 'Not found'}</div>
                            </div>
                        </div>

                        {matchedRecord && (
                            <div style={{ marginTop: '16px' }} className="data-item">
                                <div className="data-label">Matched Excel Record</div>
                                <div className="data-value">
                                    <div><strong>Budget Item:</strong> {matchedRecord.budgetItemNo || 'N/A'}</div>
                                    <div><strong>AA Amount:</strong> {matchedRecord.aaAmount ? `₹ ${matchedRecord.aaAmount.toLocaleString('en-IN')}` : 'N/A'}</div>
                                    <div><strong>Expenditure:</strong> {matchedRecord.totalExpenditure ? `₹ ${matchedRecord.totalExpenditure.toLocaleString('en-IN')}` : 'N/A'}</div>
                                    <div><strong>Match Reason:</strong> {matchInfo?.reason || 'Matched'}</div>
                                </div>
                            </div>
                        )}


                        <div className="extraction-debug">
                            <div className="debug-title">Extraction Status</div>
                            <div>
                                <strong>Found:</strong>{' '}
                                {data.extractedFields.map((f, i) => (
                                    <span key={i} className="field-status found">{f}</span>
                                ))}
                            </div>
                            {data.missingFields.length > 0 && (
                                <div style={{ marginTop: '8px' }}>
                                    <strong>Missing:</strong>{' '}
                                    {data.missingFields.map((f, i) => (
                                        <span key={i} className="field-status missing">{f}</span>
                                    ))}
                                </div>
                            )}
                        </div>

                        {data.expenditureDetails.length > 0 && (
                            <div style={{ marginTop: '16px' }}>
                                <button className="toggle-button" onClick={() => setShowBills(!showBills)}>
                                    {showBills ? '▼' : '▶'} Bills ({data.expenditureDetails.length})
                                </button>
                                <div className={`collapsible ${showBills ? 'open' : ''}`}>
                                    <table className="data-table">
                                        <thead>
                                            <tr>
                                                <th>#</th>
                                                <th>Date</th>
                                                <th>Agency</th>
                                                <th>Amount</th>
                                                <th>Cumulative</th>
                                                <th>Remark</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {data.expenditureDetails.map((bill, i) => (
                                                <tr key={i}>
                                                    <td>{i + 1}</td>
                                                    <td>{bill.date}</td>
                                                    <td>{bill.agencyName}</td>
                                                    <td>₹ {parseInt(bill.billAmount || 0).toLocaleString('en-IN')}</td>
                                                    <td>₹ {parseInt(bill.cumulativeAmount || 0).toLocaleString('en-IN')}</td>
                                                    <td>{bill.remark}</td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        )}

                        <button className="toggle-button" onClick={() => setShowRawText(!showRawText)}>
                            {showRawText ? '▼' : '▶'} Raw Text
                        </button>
                        <div className={`collapsible ${showRawText ? 'open' : ''}`}>
                            <div className="raw-text">{data.rawText}</div>
                        </div>
                    </div>

                    <div className="section">
                        <div className="section-title"> Red Flags ({doc.flags.length})</div>
                        
                        {doc.flags.length === 0 ? (
                            <div className="no-flags">
                                <div className="no-flags-icon"></div>
                                <div style={{ fontSize: '18px', fontWeight: '600', color: '#2E7D32' }}>
                                    No Red Flags - Document Compliant
                                </div>
                            </div>
                        ) : (
                            doc.flags.map((flag, i) => (
                                <div key={i} className={`flag-alert ${flag.severity}`}>
                                    <div className="flag-header">
                                        <div className="flag-icon">⚠</div>
                                        <div className="flag-info">
                                            <div className="flag-name">{flag.ruleName}</div>
                                            <div className="flag-description">{flag.description}</div>
                                        </div>
                                        <div className={`flag-severity ${flag.severity}`}>{flag.severity}</div>
                                    </div>
                                    <div className="flag-evidence">
                                        <div className="evidence-title">Evidence</div>
                                        {Object.entries(flag.details).map(([k, v], j) => (
                                            <div key={j} className="evidence-item">
                                                <div className="evidence-label">{k}</div>
                                                <div className="evidence-value">{v}</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        }

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
    {% endraw %}
</body>
</html>
